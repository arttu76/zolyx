; ==========================================================================
; DEATH HANDLER, GAME OVER & SCORING ($C617-$C7B4)
; ==========================================================================
;
; This module handles four major game events:
;
;   1. PAUSE         - Suspends gameplay when 'P' is pressed
;   2. DEATH         - Player killed by chaser/spark collision
;   3. GAME OVER     - No lives remaining; displays message and returns to menu
;   4. OUT OF TIME   - Timer expired; displays message then game over
;
; It also contains the scoring and percentage calculation routines that
; determine the player's score and whether the level is complete.
;
; ==========================================================================
;
; CHECK PAUSE ($C617):
;   Checks if P key is pressed. If so, displays pause overlay and waits
;   for the player to select "Continue" or "Abort".
;
;   Entry: Called from main game loop each frame.
;   Exit:  Z flag = 0 if "Continue" selected (XBDF6 != 1)
;          Z flag = 1 if "Abort" selected (XBDF6 == 1)
;          Carry = set if P not pressed (early return)
;
; DEATH HANDLER ($C64F):
;   Called when collision detected (bit 0 of $B0C8):
;     1. Play buzzing/explosion sound effect via port $FE
;     2. Erase all sprites (restore their backgrounds)
;     3. Erase all 8 spark old-positions from the bitmap
;     4. If player was in drawing mode:
;        a. Flash trail cells 3 times (trail -> claimed -> empty patterns)
;        b. Reset trail buffer and frame counter
;        c. Restore player position to where drawing started
;        d. Deactivate trail cursor
;     5. Continue moving chasers during the death sound loop
;     6. Decrement lives ($B0C2)
;     7. If lives > 0: restart level ($C377) - grid preserved, entities reset
;     8. If lives == 0: fall through to game over sequence
;
;   NOTE: Chasers keep patrolling during the death sound animation.
;   The death sound is generated by toggling the speaker bit on port $FE
;   with pseudo-random timing, creating a buzzing/explosion noise.
;
; GAME OVER ($C674):
;   Displays "Game Over" popup with rainbow color cycling effect.
;   Same bordered rectangle mechanism as the level complete popup.
;   Finalizes the score, waits for a keypress, then returns to menu.
;
; OUT OF TIME ($C6C9):
;   Displays "Out of Time" / "Game Over" (two-line popup) with rainbow
;   cycling, then falls through to the same finalization as game over.
;
; SCORE FINALIZE ($C6F6):
;   Formula: final_score = base_score + (rawPercentage + filledPercentage) * 4
;   Both percentage accumulators are cleared to 0 after being consumed.
;   The *4 multiplication is done via two ADD HL,HL (shift left twice).
;
;   Entry: No register requirements (reads from memory).
;   Exit:  BASE_SCORE ($B0C3) updated with final score.
;          RAW_PERCENT ($B0C5) and FILL_PERCENT ($B0C6) set to 0.
;
; ERASE SPRITES AND TRAIL ($C710):
;   Sub-routine called by DEATH_HANDLER to clean up the screen:
;     1. Restore background behind all 4 sprite types (chasers, cursor, player)
;     2. Erase all 8 sparks' old positions from the bitmap (set to empty)
;     3. If player was drawing (bit 7 of PLAYER_FLAGS at $B0E1):
;        - Flash trail 3 times with decreasing cell patterns
;        - Reset trail buffer pointer to $9000
;        - Restore player X,Y to drawing start position ($B0E4)
;        - Clear trail cursor active flag and frame counter
;
; PERCENTAGE CALCULATION ($C780):
;   Two-pass scan of the game grid to determine percentages:
;
;   Pass 1 (XCDE8): Count "claimed" cells only.
;     - Scans grid row table at $FC40 (80 rows x 32 bytes)
;     - A cell is "claimed" if it is non-zero AND (value XOR $55) masked
;       with the cell position equals zero. This specifically matches the
;       claimed pattern ($55/$00) and excludes trail ($AA/$55) and border ($FF).
;     - rawPercent = claimedCount / 90
;     - Divisor 90 comes from: interior is 122 x 74 = 9028 cells, at 4 cells
;       per byte in 2-bit encoding. 9028/100 ~ 90.28, truncated to 90.
;
;   Pass 2 (XCDBC): Count ALL non-empty cells (claimed + trail + border).
;     - Any cell that is non-zero counts.
;     - Subtract 396 (border cell count: 124*2 + 74*2 = 396 fixed border cells)
;     - fillPercent = (allNonEmpty - 396) / 90
;
;   Win check: if fillPercent >= 75 ($4B hex), set bit 2 of STATE_FLAGS ($B0C8),
;   which the main loop checks to trigger level complete.
;
;   Display score = base_score + (rawPercent + fillPercent) * 4
;
;   Entry: Called after each fill operation completes.
;   Exit:  RAW_PERCENT ($B0C5) and FILL_PERCENT ($B0C6) updated.
;          STATE_FLAGS bit 2 set if level is complete (>= 75% filled).
;          Score and percentage HUD elements refreshed on screen.
;


; ==========================================================================
; CHECK PAUSE - Pause menu handler
; ==========================================================================
;
; Called every frame from the main loop to poll the 'P' key.
; If P is pressed, displays a popup with "Game Paused" and two menu
; options: "Continue" (resume play) and "Abort" (end current game).
;
; The routine uses the generic menu selection system (XBF18/XBF3A/XBF61)
; which handles arrow key navigation, highlighting, and fire/enter to select.
;
; Entry: None.
; Exit:  If P not pressed: returns with carry set (RET C at $C61A).
;        If P pressed and menu used:
;          A = menu selection index from XBDF6
;          Z flag set if A == 1 (Abort selected)
;          Z flag clear if A == 0 (Continue selected)
;
; Calls: XBA9D (keyboard scan), RESET_BRIGHT_FIELD ($D3D3),
;        DRAW_BORDERED_RECT ($BF70), STRING_RENDERER ($BC26),
;        XBF18 (init menu), XBF3A (poll menu), XBF61 (confirm selection),
;        RESTORE_RECT ($C03E), SET_BRIGHT_FIELD ($D3C4).
; ==========================================================================

; --- Check pause ---
CHECK_PAUSE:	CALL	XBA9D		; c617  cd 9d ba	Check if 'P' key is pressed (reads keyboard rows $7F and $FE)
	RET	C		; c61a  d8		If carry set, 'P' is NOT pressed -- return immediately to game loop
	CALL	RESET_BRIGHT_FIELD		; c61b  cd d3 d3	Dim the game field by clearing BRIGHT bit on all field attributes (rows 4-23)
	LD	BC,X0B08	; c61e  01 08 0b	B=8 (row), C=11 (column) -- top-left corner of popup rectangle in character coords
	LD	DE,X0710	; c621  11 10 07	D=16 (width in chars), E=7 (height in chars) -- popup dimensions
	LD	A,68H		; c624  3e 68		A=$68 = attribute byte: BRIGHT=1, PAPER=5(cyan), INK=0(black) -- popup color
	CALL	DRAW_BORDERED_RECT		; c626  cd 70 bf	Draw the popup rectangle with a 1-pixel black border, saving what was underneath
	LD	HL,XC5EC	; c629  21 ec c5	HL -> "Game Paused" / "Continue" / "Abort" string data (defined in main_loop.asm)
	CALL	STRING_RENDERER		; c62c  cd 26 bc	Render the pause menu text strings with embedded positioning/color control codes
	LD	HL,XC610	; c62f  21 10 c6	HL -> menu descriptor table for Continue/Abort selection (2 items)
	CALL	XBF18		; c632  cd 18 bf	Initialize the menu selection system: set up highlight cursor and key handlers

; --------------------------------------------------------------------------
; Pause menu input loop: repeatedly poll for menu navigation until the
; player confirms a selection with fire/enter.
; XBF3A reads keyboard and updates the highlighted menu item.
; Returns carry set when a selection is confirmed.
; --------------------------------------------------------------------------
XC635:	CALL	XBF3A		; c635  cd 3a bf	Poll keyboard for menu navigation (up/down arrows move highlight)
	JR	NC,XC635	; c638  30 fb		If carry not set, no selection confirmed yet -- keep polling
	CALL	XBF61		; c63a  cd 61 bf	Selection confirmed: finalize choice, play confirmation sound

; --------------------------------------------------------------------------
; Restore the screen area that was behind the popup rectangle.
; Then check if BRIGHT was already off (XBDF6 tracks the context).
; If the field was already dimmed, don't re-brighten it.
; --------------------------------------------------------------------------
	CALL	RESTORE_RECT		; c63d  cd 3e c0	Restore the bitmap and attributes that were saved before drawing the popup
	LD	A,(XBDF6)	; c640  3a f6 bd	A = menu selection result (0=Continue, 1=Abort) -- also used as context flag
	OR	A		; c643  b7		Test if A is zero (Continue selected)
	JR	NZ,XC649	; c644  20 03		If non-zero (Abort), skip re-brightening the field -- game is ending
	CALL	SET_BRIGHT_FIELD		; c646  cd c4 d3	Continue selected: restore BRIGHT bit on field attributes (undo the dimming)
XC649:	LD	A,(XBDF6)	; c649  3a f6 bd	Reload menu selection index into A
	CP	1		; c64c  fe 01		Compare with 1: sets Z flag if Abort was chosen
	RET			; c64e  c9		Return to caller (main loop). Z=1 means Abort, Z=0 means Continue.
;


; ==========================================================================
; DEATH HANDLER - Player killed by collision
; ==========================================================================
;
; Entry point when the main loop detects bit 0 of STATE_FLAGS ($B0C8) is set,
; indicating the player has collided with a chaser, spark, or trail cursor.
;
; The death sequence:
;   1. Play a buzzing/explosion sound effect using the speaker (port $FE).
;      The sound is generated by XBB20, which toggles the speaker bit with
;      pseudo-random delays, creating noise. DE=$FF70 sets the pitch/duration.
;   2. Erase all sprites and clean up the trail (sub-routine at $C710).
;   3. Run a collision-check + chaser-movement loop that keeps the chasers
;      patrolling the walls even while the death animation plays. This loop
;      exits when CHECK_COLLISIONS returns carry clear (no collision), which
;      happens after the sound/animation completes and positions diverge.
;   4. Decrement the lives counter. If lives > 0, restart the level
;      (preserving the grid state but resetting entities). If lives == 0,
;      fall through to the GAME_OVER sequence.
;
; Entry: Called from main game loop when death condition is detected.
; Exit:  If lives > 0: jumps to RESTART_LEVEL ($C377), does not return.
;        If lives == 0: falls through to GAME_OVER ($C674).
;
; Calls: XBB20 (sound effect), XC710 (erase sprites/trail),
;        CHECK_COLLISIONS ($CAA9), MOVE_CHASER ($CB03).
; ==========================================================================

; --- Death handler ---
DEATH_HANDLER:	LD	DE,XFF70	; c64f  11 70 ff	DE = $FF70: sound parameters (D=$FF pitch, E=$70 duration) for death explosion
	CALL	XBB20		; c652  cd 20 bb	Play death sound effect: toggles speaker on port $FE with pseudo-random delays
	CALL	XC710		; c655  cd 10 c7	Erase all sprites from screen & clean up trail (see $C710 below)

; --------------------------------------------------------------------------
; Post-death chaser movement loop:
; After the death sound plays, chasers continue patrolling the walls.
; CHECK_COLLISIONS returns carry set if player is still overlapping an enemy.
; We keep moving chasers until the collision resolves (carry clear = no overlap).
; This ensures chasers don't freeze in place during death processing.
; --------------------------------------------------------------------------
XC658:	CALL	CHECK_COLLISIONS		; c658  cd a9 ca	Check if player overlaps chaser1, chaser2, or trail cursor (carry=collision)
	JR	NC,XC66D	; c65b  30 10		If carry clear (no collision), exit loop -- proceed to life decrement
	LD	IX,CHASER1_DATA	; c65d  dd 21 28 b0	IX -> chaser 1 data structure at $B028 (X, Y, direction, wall-side, sprite bg)
	CALL	MOVE_CHASER		; c661  cd 03 cb	Advance chaser 1 one step along its wall-following path
	LD	IX,CHASER2_DATA	; c664  dd 21 4d b0	IX -> chaser 2 data structure at $B04D
	CALL	MOVE_CHASER		; c668  cd 03 cb	Advance chaser 2 one step along its wall-following path
	JR	XC658		; c66b  18 eb		Loop back to re-check collisions (chasers keep moving until positions diverge)
;

; --------------------------------------------------------------------------
; Decrement lives. If any remain, restart the current level.
; If zero lives left, fall through to GAME OVER.
; --------------------------------------------------------------------------
XC66D:	LD	HL,LIVES	; c66d  21 c2 b0	HL -> lives counter at $B0C2
	DEC	(HL)		; c670  35		Decrement lives by 1
	JP	NZ,RESTART_LEVEL	; c671  c2 77 c3	If lives > 0 (non-zero): jump to $C377 to restart level (grid kept, entities reset)


; ==========================================================================
; GAME OVER - No lives remaining
; ==========================================================================
;
; Displays a centered "Game Over" popup with a rainbow color cycling effect,
; then finalizes the score, waits for a keypress, and returns to the main
; menu system.
;
; The popup is drawn as a bordered rectangle with attribute $68 (BRIGHT,
; cyan paper, black ink). The RAINBOW_CYCLE routine ($D415) then cycles
; the PAPER color bits through all 8 ZX Spectrum colors, creating a
; distinctive rainbow shimmer effect. The cycle runs 16 iterations with
; 2 HALT frames each = 32 frames total (~640ms at 50fps).
;
; After the rainbow, SCORE_FINALIZE adds the percentage bonuses to the
; base score, then XBAB1 waits for a keypress before cleaning up.
;
; Entry: Falls through from DEATH_HANDLER when lives == 0,
;        or jumped to directly for testing.
; Exit:  Jumps to XC6F2, which calls XB4FC (high score check) then returns.
;
; Calls: RESET_BRIGHT_FIELD ($D3D3), DRAW_BORDERED_RECT ($BF70),
;        STRING_RENDERER ($BC26), RAINBOW_CYCLE ($D415),
;        SCORE_FINALIZE ($C6F6), XBAB1 (wait for keypress),
;        RESTORE_RECT ($C03E).
; ==========================================================================

; --- Game over ---
GAME_OVER:
	CALL	RESET_BRIGHT_FIELD		; c674  cd d3 d3	Dim the game field: clear BRIGHT attribute on all field cells (rows 4-23)
	LD	BC,X0B08	; c677  01 08 0b	B=8, C=11: top-left corner of popup (row 8, column 11) in character coordinates
	LD	DE,X0510	; c67a  11 10 05	D=16, E=5: popup width=16 chars, height=5 chars
	LD	A,68H		; c67d  3e 68		A=$68: attribute byte = BRIGHT + PAPER 5 (cyan) + INK 0 (black)
	CALL	DRAW_BORDERED_RECT		; c67f  cd 70 bf	Draw bordered popup rectangle, saving underlying screen data for later restoration
	LD	HL,XC69D	; c682  21 9d c6	HL -> "Game Over" string data with embedded control codes (see DB block below)
	CALL	STRING_RENDERER		; c685  cd 26 bc	Render "Game Over" text inside the popup
	LD	BC,X0B08	; c688  01 08 0b	B=8, C=11: same top-left corner as the popup (for rainbow cycling region)
	LD	DE,X0510	; c68b  11 10 05	D=16, E=5: same dimensions (cycle colors on the entire popup area)
	CALL	RAINBOW_CYCLE		; c68e  cd 15 d4	Rainbow cycle: rotate PAPER color through all 8 ZX colors, 32 frames (~640ms)
	CALL	SCORE_FINALIZE		; c691  cd f6 c6	Compute final score: base_score += (rawPercent + fillPercent) * 4
	CALL	XBAB1		; c694  cd b1 ba	Wait for any key to be pressed (first waits for all keys released, then any press)
	CALL	RESTORE_RECT		; c697  cd 3e c0	Restore the screen area behind the popup (bitmap + attributes)
	JP	XC6F2		; c69a  c3 f2 c6	Jump to high score check and return to menu

; --------------------------------------------------------------------------
; String data blocks for the popup messages.
;
; Format: Control codes are single bytes that the STRING_RENDERER interprets:
;   $1E xx  = set attribute byte for subsequent characters
;   $1F xx  = set cursor position (encoded screen address)
;   $0D     = carriage return / line positioning marker
;   $0F     = secondary text style marker
;   $00     = end of string
;
; XC69D: "Game Over" (single-line popup, used by GAME_OVER)
; XC6AC: "Out of Time" + "Game Over" (two-line popup, used by OUT_OF_TIME)
; --------------------------------------------------------------------------
;
XC69D:	DB	1EH,68H,1FH,60H,0DH			; c69d  Attr=$68 (bright cyan/black), cursor pos=$60, newline
	DB	'Game Over'				; c6a2  The game over message text
	DB	0					; c6ab  End of string marker
XC6AC:	DB	1EH,68H,1FH,5EH,0DH			; c6ac  Attr=$68, cursor pos=$5E (slightly higher for 2-line layout), newline
	DB	'Out of Time'				; c6b1  First line: timeout message
	DB	1FH,60H,0FH				; c6bc  Cursor reposition to $60 for second line, style change
	DB	'Game Over'				; c6bf  Second line: game over text
	DB	0					; c6c8  End of string marker
;


; ==========================================================================
; OUT OF TIME - Timer reached zero
; ==========================================================================
;
; Displayed when the game timer ($B0C0) reaches 0. This shows a taller
; popup with both "Out of Time" and "Game Over" text, then goes through
; the same score finalization and high score flow as a normal game over.
;
; The popup is 7 rows tall (vs 5 for game-over) to fit the two lines.
;
; Entry: Called from main loop when bit 1 of STATE_FLAGS ($B0C8) is set
;        (timer expired flag).
; Exit:  Jumps to XC6F2, which calls XB4FC (high score check) then returns.
;
; Calls: Same as GAME_OVER, plus references XC6AC string block.
; ==========================================================================

; --- Out of time ---
OUT_OF_TIME:	CALL	RESET_BRIGHT_FIELD		; c6c9  cd d3 d3	Dim field: clear BRIGHT on all field attributes
	LD	BC,X0B08	; c6cc  01 08 0b	B=8, C=11: popup top-left corner (row 8, col 11)
	LD	DE,X0710	; c6cf  11 10 07	D=16, E=7: popup width=16, height=7 (taller to fit two text lines)
	LD	A,68H		; c6d2  3e 68		A=$68: BRIGHT + cyan paper + black ink
	CALL	DRAW_BORDERED_RECT		; c6d4  cd 70 bf	Draw bordered popup, save underlying screen
	LD	HL,XC6AC	; c6d7  21 ac c6	HL -> "Out of Time" / "Game Over" two-line string data
	CALL	STRING_RENDERER		; c6da  cd 26 bc	Render both text lines inside the popup
	LD	BC,X0B08	; c6dd  01 08 0b	B=8, C=11: rainbow region top-left (matches popup)
	LD	DE,X0710	; c6e0  11 10 07	D=16, E=7: rainbow region dimensions (full popup area)
	CALL	RAINBOW_CYCLE		; c6e3  cd 15 d4	Rainbow cycle the popup PAPER color (~640ms visual effect)
	CALL	SCORE_FINALIZE		; c6e6  cd f6 c6	Compute final score: base_score += (rawPercent + fillPercent) * 4
	CALL	XBAB1		; c6e9  cd b1 ba	Wait for keypress: first ensures all keys are up, then waits for any key down
	CALL	RESTORE_RECT		; c6ec  cd 3e c0	Restore screen area behind the popup
	JP	XC6F2		; c6ef  c3 f2 c6	Jump to high score check routine
;

; --------------------------------------------------------------------------
; Common exit point for GAME_OVER and OUT_OF_TIME.
; XB4FC checks if the player's score qualifies for the high score table.
; If it does, it displays the high score entry screen.
; Then returns to the main menu loop.
; --------------------------------------------------------------------------
XC6F2:	CALL	XB4FC		; c6f2  cd fc b4	Check/update high score table at $C18D (10 entries, compares BASE_SCORE)
	RET			; c6f5  c9		Return to caller (ultimately back to the main menu system)
;


; ==========================================================================
; SCORE FINALIZE - Add percentage bonus to base score
; ==========================================================================
;
; Computes the final display score by adding a bonus derived from both
; percentage values to the running base score.
;
; Formula:
;   bonus = (FILL_PERCENT + RAW_PERCENT) * 4
;   BASE_SCORE = BASE_SCORE + bonus
;
; Both percentage accumulators are reset to 0 after being consumed,
; preventing double-counting on subsequent calls.
;
; The *4 multiplier is implemented as two left shifts (ADD HL,HL twice),
; which is the standard Z80 idiom for multiplying by a power of 2.
;
; Entry: No register requirements. Reads from:
;          FILL_PERCENT ($B0C6) - filled area percentage (0-100)
;          RAW_PERCENT  ($B0C5) - claimed cells percentage (0-100)
;          BASE_SCORE   ($B0C3) - current 16-bit score
; Exit:  BASE_SCORE ($B0C3) updated with bonus added.
;        FILL_PERCENT and RAW_PERCENT both set to 0.
;        All registers modified.
;
; NOTE: The final two instructions (LD (BASE_SCORE),HL / RET) are encoded
; as raw DB bytes ($22, low, high, $C9) because the disassembler could not
; resolve them cleanly. They are: LD ($B0C3),HL followed by RET.
; ==========================================================================

; --- Score finalize ---
SCORE_FINALIZE:	LD	HL,FILL_PERCENT	; c6f6  21 c6 b0	HL -> filled percentage at $B0C6
	LD	A,(HL)		; c6f9  7e		A = current filled percentage value (0-100)
	LD	(HL),0		; c6fa  36 00		Clear filled percentage to 0 (consumed; prevents double-counting)
	LD	HL,RAW_PERCENT	; c6fc  21 c5 b0	HL -> raw claimed percentage at $B0C5
	ADD	A,(HL)		; c6ff  86		A = fillPercent + rawPercent (sum of both percentage values)
	LD	(HL),0		; c700  36 00		Clear raw percentage to 0 (consumed)
	LD	L,A		; c702  6f		L = sum (low byte of 16-bit value)
	LD	H,0		; c703  26 00		H = 0: HL now holds the percentage sum as a 16-bit number
	ADD	HL,HL		; c705  29		HL = sum * 2 (first left shift)
	ADD	HL,HL		; c706  29		HL = sum * 4 (second left shift; this is the percentage bonus)
	LD	DE,(BASE_SCORE)	; c707  ed 5b c3 b0	DE = current base score (16-bit little-endian from $B0C3-$B0C4)
	ADD	HL,DE		; c70b  19		HL = base_score + (fillPercent + rawPercent) * 4 = final score
;
; The following bytes encode: LD (BASE_SCORE),HL  /  RET
; The disassembler output these as raw DB because of alignment/label issues.
; $22 = opcode for LD (nn),HL; $C3,$B0 = address $B0C3; $C9 = RET.
;
	DB	22H					; c70c  LD (nn),HL opcode
	DW	BASE_SCORE		; c70d   c3 b0      Address $B0C3 (BASE_SCORE)
;
	DB	0C9H					; c70f  RET opcode -- returns to caller
;


; ==========================================================================
; ERASE SPRITES AND TRAIL ($C710) - Death cleanup sub-routine
; ==========================================================================
;
; Called by DEATH_HANDLER to clean up the screen before the death sequence
; continues. This routine:
;
;   Phase 1: Restore sprite backgrounds.
;     Calls RESTORE_SPRITE_BG for each of the 4 sprite entities in reverse
;     drawing order (chaser2, chaser1, trail cursor, player). This undoes
;     the sprite blitting by writing back the saved background pixels.
;     Reverse order ensures correct restoration when sprites overlap.
;
;   Phase 2: Erase spark old-positions.
;     Iterates through all 8 spark entries in the spark data array.
;     Each spark is 5 bytes: X, Y, oldX, oldY, direction.
;     We start at $B099 (spark[0].oldX) and write empty cells (value 0)
;     at each spark's previous position using WRITE_CELL_BMP ($CEAE).
;     This erases spark trails from the bitmap without affecting the
;     shadow grid (sparks are bitmap-only entities).
;
;   Phase 3: Trail flash animation (only if player was in drawing mode).
;     Checks bit 7 of PLAYER_FLAGS ($B0E1). If clear (not drawing), skips
;     to RET. If set:
;     - Clears bit 7 (exits drawing mode)
;     - Runs 3 passes over the trail buffer ($9000):
;       Pass 1: B=3 -> C=2 (trail pattern $AA/$55: re-draw trail pattern)
;       Pass 2: B=2 -> C=1 (claimed pattern $55/$00: flash to lighter)
;       Pass 3: B=1 -> C=0 (empty pattern $00/$00: erase trail completely)
;     - Each pass rewrites every trail point with the given cell value,
;       creating a 3-step fade-out animation, with 8 frames delay between.
;     - After animation: resets trail buffer, restores player position to
;       the drawing start point, and deactivates the trail cursor.
;
; Entry: Called from DEATH_HANDLER after the death sound plays.
; Exit:  All sprites erased, sparks cleaned up, trail removed if active.
;        Player position restored to drawing start (if was drawing).
;        Trail cursor deactivated, trail frame counter reset.
;
; Calls: RESTORE_SPRITE_BG ($D0E5) x4, WRITE_CELL_BMP ($CEAE) x8,
;        XCEB1 (write cell to bitmap at coords), FRAME_DELAY ($BB48).
; ==========================================================================

; --- Phase 1: Restore all sprite backgrounds ---

XC710:	LD	HL,CHASER2_DATA	; c710  21 4d b0	HL -> chaser 2 data at $B04D (restore last-drawn sprite first)
	CALL	RESTORE_SPRITE_BG		; c713  cd e5 d0	Restore the background pixels that were saved before chaser 2 was drawn
	LD	HL,CHASER1_DATA	; c716  21 28 b0	HL -> chaser 1 data at $B028
	CALL	RESTORE_SPRITE_BG		; c719  cd e5 d0	Restore background behind chaser 1
	LD	HL,TRAIL_CURSOR	; c71c  21 72 b0	HL -> trail cursor data at $B072
	CALL	RESTORE_SPRITE_BG		; c71f  cd e5 d0	Restore background behind trail cursor
	LD	HL,PLAYER_XY	; c722  21 03 b0	HL -> player position/data at $B003
	CALL	RESTORE_SPRITE_BG		; c725  cd e5 d0	Restore background behind player sprite

; --------------------------------------------------------------------------
; Phase 2: Erase all 8 sparks' old positions from the bitmap.
;
; Spark data array starts at $B097, each entry is 5 bytes:
;   +0: current X   +1: current Y   +2: old X   +3: old Y   +4: direction
;
; We start HL at $B099 (spark[0].oldX) to read old positions.
; For each spark: load oldX into E, oldY into D, then call WRITE_CELL_BMP
; with A=0 (empty cell) to erase the spark's previous bitmap footprint.
; After loading 2 bytes (oldX, oldY), advance HL by 3 more bytes to reach
; the next spark's oldX (5 bytes per entry - 2 already read = 3 to skip).
;
; NOTE: This section was not cleanly disassembled -- the original tool
; output raw DB bytes. The actual Z80 instructions are documented below.
; --------------------------------------------------------------------------

	LD	HL,XB099	; c728  21 99 b0	HL -> spark[0].oldX at $B099 (2 bytes into first spark entry)
	LD	B,8		; c72b  06 08		B = 8: loop counter for all 8 spark slots
;
; --- Spark erase loop (raw bytes $C72D-$C73E) ---
; Decoded Z80 instructions:
;   $C72D: LD   E,(HL)         ; E = spark old X coordinate
;   $C72E: INC  HL             ; advance to old Y
;   $C72F: LD   D,(HL)         ; D = spark old Y coordinate
;   $C730: INC  HL             ; skip past old Y -> direction byte
;   $C731: INC  HL             ; skip direction -> next spark X
;   $C732: INC  HL             ; skip next spark X -> next spark Y
;   $C733: INC  HL             ; skip next spark Y -> next spark oldX (ready for next iteration)
;   $C734: PUSH BC             ; save loop counter
;   $C735: PUSH HL             ; save pointer to next spark's oldX
;   $C736: LD   A,0            ; A = 0 = empty cell pattern
;   $C738: CALL WRITE_CELL_BMP ; write empty cell at pixel coords (D,E) -- erases spark from bitmap only
;                               ;   (WRITE_CELL_BMP = $CEAE; does NOT touch shadow grid at $6000)
;   $C73B: POP  HL             ; restore spark array pointer
;   $C73C: POP  BC             ; restore loop counter in B
;   $C73D: DJNZ $C72D          ; decrement B; if non-zero, loop back for next spark (offset $EE = -18)
;
	DB	'^#V####'				; c72d  5E 23 56 23 23 23 23 (LD E,(HL) / INC HL / LD D,(HL) / INC HL x4)
	DB	0C5H,0E5H,3EH,0,0CDH,0AEH		; c734  PUSH BC / PUSH HL / LD A,0 / CALL $CEAE (first 2 bytes of address)
	DW	XE1CE		; c73a   ce e1      ...high byte of CALL addr ($CE) / POP HL ($E1)
;
	DB	0C1H,10H				; c73c  POP BC ($C1) / DJNZ opcode ($10)
	DW	X21EE		; c73e   ee 21      ...DJNZ offset ($EE=-18, loops to $C72D) / start of LD HL,nn ($21)
;
; --------------------------------------------------------------------------
; Phase 3: Check if player was in drawing mode; if so, animate trail erasure.
;
; After the spark erase loop falls through (B=0), the DJNZ offset byte at
; $C73E ($EE) is consumed, and execution continues at $C73F.
;
; Decoded instructions at $C73F:
;   $C73F: LD   HL,$B0E1       ; HL -> PLAYER_FLAGS
;   $C742: BIT  7,(HL)         ; test bit 7: was player in drawing mode?
;   $C744: JR   Z,$C77F        ; if NOT drawing: skip trail cleanup, jump to RET
;   $C746: RES  7,(HL)         ; clear drawing mode flag (player is no longer drawing)
;
; If player WAS drawing (bit 7 was set), we animate the trail erasure:
;
;   $C748: LD   B,3            ; outer loop: 3 passes of trail rewriting
;   $C74A: LD   C,B            ; C = current pass number (3, 2, 1)
;   $C74B: DEC  C              ; C = pass-1 (2, 1, 0) = cell value to write:
;                               ;   C=2: trail pattern ($AA/$55) -- redraw trail
;                               ;   C=1: claimed pattern ($55/$00) -- lighter flash
;                               ;   C=0: empty pattern ($00/$00) -- erase completely
;   $C74C: LD   HL,$9000       ; HL -> start of trail buffer (3 bytes per point: X, Y, direction)
;   --- Inner loop: iterate over all trail entries ---
;   $C74F: LD   A,(HL)         ; A = trail entry X coordinate
;   $C750: OR   A              ; test if zero (end-of-trail sentinel)
;   $C751: JR   Z,$C762        ; if zero: no more trail entries, skip to frame delay
;   $C753: LD   E,A            ; E = trail X coordinate
;   $C754: INC  HL             ;
;   $C755: LD   D,(HL)         ; D = trail Y coordinate
;   $C756: INC  HL             ; skip Y
;   $C757: INC  HL             ; skip direction byte (advance 3 bytes total to next entry)
;   $C758: LD   A,C            ; A = cell value for this pass (2, 1, or 0)
;   $C759: PUSH BC             ; save loop counters
;   $C75A: PUSH HL             ; save trail buffer pointer
;   $C75B: CALL $CEB1          ; XCEB1: write cell value A at grid coords (D,E) on bitmap
;                               ;   (XCEB1 = COORDS_TO_ADDR + cell write; bitmap only, not shadow)
;   $C75E: POP  HL             ; restore trail pointer
;   $C75F: POP  BC             ; restore loop counters
;   $C760: JR   $C74F          ; loop back to process next trail entry (offset $ED = -19)
;   --- End of inner loop ---
;   $C762: LD   A,8            ; A = 8: number of frames to delay between passes
;   $C764: CALL FRAME_DELAY    ; ($BB48) wait 8 frames = 160ms at 50fps (visible flash timing)
;   $C767: DJNZ $C74A          ; decrement outer counter B; loop for next pass (offset $E1 = -31)
;
; After 3 passes complete (trail fully erased), reset game state:
;
;   $C769: LD   HL,$9000       ; HL -> trail buffer start
;   $C76C: LD   (HL),0         ; write 0 sentinel at buffer start (mark trail as empty)
;   $C76E: LD   ($B0E6),HL     ; reset TRAIL_WRITE_PTR to $9000 (start of buffer)
;   $C771: LD   HL,($B0E4)     ; HL = drawing start position (X,Y saved when drawing began)
;   $C774: LD   ($B003),HL     ; restore PLAYER_XY to the position where drawing started
;                               ;   (player snaps back to the border point where they entered)
;   $C777: LD   A,0            ; A = 0
;   $C779: LD   ($B072),A      ; clear TRAIL_CURSOR X position (0 = cursor inactive)
;   $C77C: LD   ($B0E8),A      ; clear TRAIL_FRAME_CTR (reset countdown to cursor activation)
;   $C77F: RET                  ; return to DEATH_HANDLER
; --------------------------------------------------------------------------
;
	DB	0E1H,0B0H				; c740  ...LD HL,$B0E1 (low=$E1, high=$B0) -- these are the operand bytes
	DW	X7ECB		; c742   cb 7e      BIT 7,(HL) -- test drawing mode flag in PLAYER_FLAGS
;
	DB	28H,39H					; c744  JR Z,$C77F (offset $39=+57) -- skip if not drawing, go to RET
	DW	XBECB		; c746   cb be      RES 7,(HL) -- clear drawing mode flag
;
; --- Trail flash animation: 3 passes with frame delay ---
;
	DB	6,3,48H,0DH,21H,0,90H,7EH		; c748  LD B,3 / LD C,B / DEC C / LD HL,$9000 / LD A,(HL)
	DB	0B7H,28H,0FH				; c750  OR A / JR Z,$C762
	DB	'_#V##y'				; c753  LD E,A / INC HL / LD D,(HL) / INC HL / INC HL / LD A,C
	DB	0C5H,0E5H,0CDH				; c759  PUSH BC / PUSH HL / CALL... (first byte of CALL opcode)
	DW	XCEB1		; c75c   b1 ce      ...$CEB1 (write cell to bitmap at coords D,E with value A)
;
	DB	0E1H,0C1H,18H				; c75e  POP HL / POP BC / JR... (inner loop back to $C74F, offset $ED)
	DW	X3EED		; c761   ed 3e      ...offset $ED (-19) / LD A,nn (A=8 frames)
	DB	8					; c763  ...operand: 8 frames for FRAME_DELAY
	DW	X48CD		; c764   cd 48      CALL $BB48... (FRAME_DELAY)
	DW	X10BB		; c766   bb 10      ...$BB48 complete / DJNZ outer loop (offset $E1 = -31 -> $C74A)
;
; --- After trail animation: reset trail state and player position ---
;
	DB	0E1H,21H,0,90H,36H,0,22H,0E6H		; c768  (DJNZ offset $E1) / LD HL,$9000 / LD (HL),0 / LD ($B0E6),HL
	DB	0B0H,2AH,0E4H,0B0H,22H,3,0B0H,3EH	; c770  ...($B0E6) / LD HL,($B0E4) / LD ($B003),HL / LD A,...
	DB	0,32H,72H,0B0H,32H			; c778  ...A=0 / LD ($B072),A / LD ($B0E8),...
	DW	TRAIL_FRAME_CTR		; c77d   e8 b0      ...$B0E8 / ...A (clear trail frame counter)
;
	DB	0C9H					; c77f  RET -- return to DEATH_HANDLER (or skip-to-here if not drawing)
;


; ==========================================================================
; CALC PERCENTAGE - Count filled cells and compute percentages
; ==========================================================================
;
; This routine performs two full scans of the game grid to compute:
;   1. rawPercent  - percentage of cells that are specifically "claimed" (value 1)
;   2. fillPercent - percentage of the interior that is non-empty (any value)
;
; The grid uses 2-bit cell encoding (4 cells per byte):
;   0 = empty, 1 = claimed, 2 = trail, 3 = border
;
; PASS 1 - Count claimed cells (XCDE8):
;   Scans the grid row pointer table starting at $FC40 (80 rows of 32 bytes).
;   For each 2-bit cell, checks if it is specifically the "claimed" pattern:
;   the cell is non-zero AND (cell XOR $55) masked equals zero, which matches
;   only the $55 (claimed) pattern. Trail ($AA) and border ($FF) are excluded.
;   Returns count in HL.
;   rawPercent = count / 90 (stored in C after division).
;   The divisor 90 ($5A) approximates interior_cells/100 = 9028/100 ~ 90.
;
; PASS 2 - Count all non-empty cells (XCDBC):
;   Scans the same grid but counts ALL non-zero cells (claimed + trail + border).
;   Returns count in HL.
;   Subtract 396 ($018C) to remove the fixed border cells from the count:
;     Border = 124*2 (top+bottom rows) + 74*2 (left+right columns) = 396 cells.
;   fillPercent = (count - 396) / 90.
;
; DIVISION - XD14F:
;   16-bit division: BC / DE -> quotient in BC, remainder in HL.
;   Called with the cell count in BC and divisor 90 ($005A) in DE.
;   The quotient (percentage) is returned in C.
;
; WIN CHECK:
;   If fillPercent >= 75 ($4B), set bit 2 of STATE_FLAGS ($B0C8).
;   The main game loop checks this bit to trigger the level complete sequence.
;   75% is the minimum fill threshold required to advance to the next level.
;
; Finally, both the percentage display and score display are refreshed on
; the HUD to show the player their current progress.
;
; Entry: Called after each flood fill operation completes.
; Exit:  RAW_PERCENT ($B0C5) = claimed cell count / 90
;        FILL_PERCENT ($B0C6) = (non-empty count - 396) / 90
;        STATE_FLAGS bit 2 set if fillPercent >= 75 (level complete trigger)
;        On-screen percentage and score displays updated.
;
; Calls: XCDE8 (count claimed cells), XCDBC (count all non-empty cells),
;        XD14F (16-bit division), UPDATE_PERCENT_DISPLAY ($D2A3),
;        UPDATE_SCORE_DISPLAY ($D27A).
; ==========================================================================

; --- Calc percentage ---

; --- Pass 1: Count claimed cells and compute raw percentage ---
CALC_PERCENTAGE:	CALL	XCDE8		; c780  cd e8 cd	Count claimed cells: scans grid, returns count in HL (cells matching pattern $55)
	LD	B,H		; c783  44		B = high byte of claimed count (copy HL -> BC for division)
	LD	C,L		; c784  4d		C = low byte of claimed count
	LD	DE,X005A	; c785  11 5a 00	DE = 90 ($5A): divisor (interior_cells / 100 = 9028/100 ~ 90)
	CALL	XD14F		; c788  cd 4f d1	16-bit divide: BC / DE. Quotient in BC (C = rawPercent), remainder in HL.
	LD	HL,RAW_PERCENT	; c78b  21 c5 b0	HL -> RAW_PERCENT storage at $B0C5
	LD	(HL),C		; c78e  71		Store raw claimed percentage (0-100) -- only low byte needed

; --- Pass 2: Count all non-empty cells and compute fill percentage ---
	CALL	XCDBC		; c78f  cd bc cd	Count ALL non-empty cells: scans grid, returns count in HL (any non-zero cell)
	LD	DE,X018C	; c792  11 8c 01	DE = 396 ($018C): number of fixed border cells (124*2 + 74*2)
	OR	A		; c795  b7		Clear carry flag (required before SBC instruction for correct subtraction)
	SBC	HL,DE		; c796  ed 52		HL = total_non_empty - 396 = interior filled cells only (excludes border)
	LD	B,H		; c798  44		B = high byte of adjusted count (copy HL -> BC for division)
	LD	C,L		; c799  4d		C = low byte of adjusted count
	LD	DE,X005A	; c79a  11 5a 00	DE = 90: same divisor as pass 1
	CALL	XD14F		; c79d  cd 4f d1	16-bit divide: BC / DE. Quotient C = fillPercent (0-100).
	LD	HL,FILL_PERCENT	; c7a0  21 c6 b0	HL -> FILL_PERCENT storage at $B0C6
	LD	(HL),C		; c7a3  71		Store filled percentage value

; --- Win condition check: is fillPercent >= 75? ---
	LD	A,C		; c7a4  79		A = fillPercent (just computed)
	CP	4BH		; c7a5  fe 4b		Compare with 75 ($4B): the minimum fill threshold to complete the level
	JR	C,XC7AE		; c7a7  38 05		If carry set (fillPercent < 75): not enough filled -- skip level complete flag
	LD	HL,STATE_FLAGS	; c7a9  21 c8 b0	HL -> game state flags byte at $B0C8 (fillPercent >= 75: level is complete!)
	SET	2,(HL)		; c7ac  cb d6		Set bit 2 of STATE_FLAGS: "level complete" flag. Main loop will detect this.

; --- Update the on-screen HUD displays ---
XC7AE:	CALL	UPDATE_PERCENT_DISPLAY		; c7ae  cd a3 d2	Refresh the percentage number shown on the HUD (renders fillPercent as text)
	CALL	UPDATE_SCORE_DISPLAY		; c7b1  cd 7a d2	Refresh the score display on the HUD (renders base_score + bonus as 5-digit number)
	RET			; c7b4  c9		Return to caller (main loop or fill routine)
;
